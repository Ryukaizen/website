<<<<<<< Updated upstream
# Internationalization

The i18n plugin helps you with providing multiple languages for your bot. It does this by loading translation files from a directory or directly by providing the string via the loadLocale methods source option.
The plugin is based on [Fluent](https://projectfluent.org/)—a localization framework supported by [Mozilla](https://mozilla.org/).
It has a very powerful and elegant syntax that lets anyone write efficient and natural-sounding translations.

## Getting Started

There are [multiple ways](#adding-translations) to add more languages to your bot.
The easiest way is creating a folder with your fluent translation files in it.
Usually, the name of that folder is going to be `locales/`.
The translation files should have the extension `.ftl` (fluent).

Here is an example project structure:

=======
# Internationalization i18n

The i18n plugin helps you with providing multiple languages for your bot. It does this by loading translation files from a directory or directly by providing the string via the loadLocale methods source option.
But what is i18n, and what is l10n?
i18n is the tool you need to provide l10n.
The [W3C QA i18n](https://www.w3.org/International/questions/qa-i18n.en.html) defines Internationalization
"Internationalization is the design and development of a product, application or document content that enables easy localization for target audiences that vary in culture, region, or language." and Localization "Localization refers to the adaptation of a product, application or document content to meet the language, cultural and other requirements of a specific target market (a locale)."

You can see this plugin as your provider for i18n (Internationalization); we do most of the work so you can give your users a localized product (l10n).

The plugin is using [Fluent](https://projectfluent.org/)—a localization framework supported by [Mozilla](https://mozilla.org/).
It has a very powerful and elegant syntax that lets anyone write efficient and natural-sounding translations.

## Getting Started

There are [multiple ways](#adding-translations) to add more languages to your bot.
The easiest way is to create a folder with your fluent translation files.
Usually, that folder's name will be `locales/`.
The translation files should have the extension `.ftl` (fluent).

Here is an example project structure:

>>>>>>> Stashed changes
```asciiart:no-line-numbers
.
├── bot.ts
└── locales/
<<<<<<< Updated upstream
    ├── de.ftl
    ├── en.ftl
    ├── it.ftl
    └── ru.ftl
=======
 ├── de.ftl
 ├── en.ftl
 ├── it.ftl
 └── ru.ftl
>>>>>>> Stashed changes
```

If you're unfamiliar with the Fluent file (`.ftl`) syntax, you can have a look at their syntax guide here: <https://projectfluent.org/fluent/guide>

These translation files contain translations like this:

`en.ftl`
<<<<<<< Updated upstream

```fluent
start = Hi, how can I /help you?
help = 
    Send me some text and I can make it bold for you.
    You can change my language using the /language command.
=======

"`fluent
start = Hi, how can I /help you?
help =
 Send me some text, and I can make it bold for you.
 You can change my language using the /language command.

>>>>>>> Stashed changes
```

`de.ftl`

```fluent
start = Hallo, wie kann ich dir helfen? /help
help = 
<<<<<<< Updated upstream
    Schick eine Textnachricht, die ich für dich fett schreiben soll.
    Du kannst mit dem Befehl /language die Spache ändern.
=======
 Schick eine Textnachricht, die ich für dich fett schreiben soll.
 Du kannst mit dem Befehl /language die Spache ändern.
>>>>>>> Stashed changes
```

Using the translations in your bot:

```ts
bot.command("start", async (ctx) => {
<<<<<<< Updated upstream
  await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
  await ctx.reply(ctx.t("help"));
});
```

Whenever a message is sent the locale of context is used.
This could be your specific language negotiator or just `ctx.from.language_code`
So as a result different users with different locales will be able to read the messages in their languages.

## Usage

The plugin chooses the language in use by different ways. One of them is the default `ctx.from.language_code` provided by the Telegram client of the user.
If your bot has a command for changing the language it is better to use the language chosen by the user.
Based on these different language selection approaches the i18n plugin can be configured mainly in two different ways: [With sessions](#with-sessions) or [without sessions](#without-sessions).

### Without Sessions

This is easier to set up and use than using with sessions. Its main drawback is that you can’t save the chosen language of the user.
Though technically, you can just implement a [custom locale negotiator](#custom-locale-negotiation) to achieve that.

The locale for the user is selected from `ctx.from.language_code`, which is provided by the Telegram client of the user.
But if you don't have a translation of that language, the default language will be used.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

=======
 await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
 await ctx.reply(ctx.t("help"));
});
```

The best possible translation is selected for the user whenever a message is sent.
The could be your specific language negotiator or just `ctx.from.language_code`
So, as a result, different users with different locales will be able to read the messages in their languages.

## Usage

The plugin chooses the language in use in different ways. One of them is the default `ctx.from.language_code` provided by the Telegram client of the user.
If your bot has a command for changing the language, it is better to use the language chosen by the user.
Based on these different language selection approaches, the i18n plugin can be configured mainly in two different ways: [With sessions](#with-sessions) or [Without sessions](#without-sessions).

### Without Sessions

Not using sessions is easier to set up and use. Its main drawback is that you can't save the user's chosen language.
Though technically, you can implement a [custom locale negotiator](#custom-locale-negotiation) to achieve that.

The locale for the user is selected from `ctx.from.language_code`.
`ctx.from.language_code` is provided by the Telegram client.
But the plugin will use the default language if you don't have a translation of that language.

<CodeGroup>
 <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

>>>>>>> Stashed changes
// For full TypeScript support and proper auto-completion
// extend the Context with I18n's Context Flavor.
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
<<<<<<< Updated upstream
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
=======
 defaultLocale: "en", // see below for more information

 // Load all translation files from locales/.
 directory: "locales",
>>>>>>> Stashed changes
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
<<<<<<< Updated upstream
bot.use(i18n);
=======
bot.use(i18n.middleware());
>>>>>>> Stashed changes

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
<<<<<<< Updated upstream
  await ctx.reply(ctx.t("start-msg"));
=======
 await ctx.reply(ctx.t("start-msg"));
>>>>>>> Stashed changes
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot } = require("grammy");
const { I18n } = require("@grammyjs/i18n");
<<<<<<< Updated upstream

// Create a bot as you normally would.
const bot = new Bot(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
=======

// Create a bot as you normally would.
const bot = new Bot(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
 defaultLocale: "en", // see below for more information

 // Load all translation files from locales/.
 directory: "locales",
>>>>>>> Stashed changes
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
<<<<<<< Updated upstream
=======
bot.use(i18n.middleware());

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
 await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
 I18n,
 I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

// For TypeScript and auto-completion support,
// extend the context with I18n's flavor:
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
 defaultLocale: "en", // see below for more information

 // Load all translation files from locales/.
 directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
>>>>>>> Stashed changes
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
<<<<<<< Updated upstream
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

// For TypeScript and auto-completion support,
// extend the context with I18n's flavor:
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
</CodeGroup>

`ctx.t` returns the translated message for the specified key.
You don't have to worry about languages here.

Your bot is a polyglot :tada:

### With Sessions

As mentioned earlier, let's assume your bot has a `/language` command.
Generally in grammY, we can make use of [sessions](./session.md) to read and write user data.
To let your i18n instance know that sessions are enabled, you have to set `useSession` to `true` in the i18n options.

An example of implementing it, including a simple `/language` command:

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether to store user language in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
=======
 await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
</CodeGroup>

`ctx.t` returns the translated message for the specified key.
You don't have to worry about languages here.
Congratulations!
Your bot is now a polyglot :tada:

### With Sessions

As mentioned earlier, let's assume your bot has a `/language` command.
Generally, in grammY, we can use [sessions](./session.md) to read and write user data.
To let your i18n instance know that sessions are enabled, you must set `useSession` to `true` in the i18n options.

An example of implementing it, including a simple `/language` command:

<CodeGroup>
 <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

interface SessionData {
 __language_code?: string;
}

type MyContext =
 & Context
 & SessionFlavor<SessionData>
 & I18nContextFlavor;

const i18n = new I18n({
 defaultLocale: "en",
 useSession: true, // whether to store user language in session

 // Load locales from the `locales` directory.
 directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
 initial: () => {
 return {};
 },
}));

// Register i18n middleware
bot.use(i18n.middleware());

bot.command("start", async (ctx) => {
 await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
 if (ctx.match === "") {
 return await ctx.reply(ctx.t("language.specify-a-locale"));
 }

 // `i18n.locales` contains all the locales that have been registered
 if (!i18n.locales.includes(ctx.match)) {
 return await ctx.reply(ctx.t("language.invalid-locale"));
 }

 // `ctx.i18n.getLocale` returns the locale currently using.
 if (await ctx.i18n.getLocale() === ctx.match) {
 return await ctx.reply(ctx.t("language.already-set"));
 }

 await ctx.i18n.setLocale(ctx.match);
 await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const i18n = new I18n({
 defaultLocale: "en",
 useSession: true, // whether get/set in session

 // Load locales from the `locales` directory.
 directory: "locales",
});

const bot = new Bot(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
 initial: () => {
 return {};
 },
}));

// Register i18n middleware
bot.use(i18n.middleware());

bot.command("start", async (ctx) => {
 await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
 if (ctx.match === "") {
 return await ctx.reply(ctx.t("language.specify-a-locale"));
 }

 // `i18n.locales` contains all the locales that have been registered
 if (!i18n.locales.includes(ctx.match)) {
 return await ctx.reply(ctx.t("language.invalid-locale"));
 }

 // `ctx.i18n.getLocale` returns the locale currently using.
 if (await ctx.i18n.getLocale() === ctx.match) {
 return await ctx.reply(ctx.t("language.already-set"));
 }

 await ctx.i18n.setLocale(ctx.match);
 await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import {
 Bot,
 Context,
 session,
 SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import {
 I18n,
 I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
 __language_code?: string;
}

type MyContext =
 & Context
 & SessionFlavor<SessionData>
 & I18nContextFlavor;

const i18n = new I18n({
 defaultLocale: "en",
 useSession: true, // whether get/set in session

 // Load locales from the `locales` directory.
 directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
 initial: () => {
 return {};
 },
}));

// Register i18n middleware
bot.use(i18n.middleware());

bot.command("start", async (ctx) => {
 await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
 if (ctx.match === "") {
 return await ctx.reply(ctx.t("language.specify-a-locale"));
 }

 // `i18n.locales` contains all the locales that have been registered
 if (!i18n.locales.includes(ctx.match)) {
 return await ctx.reply(ctx.t("language.invalid-locale"));
 }

 // `ctx.i18n.getLocale` returns the locale currently using.
 if (await ctx.i18n.getLocale() === ctx.match) {
 return await ctx.reply(ctx.t("language.already-set"));
 }

 await ctx.i18n.setLocale(ctx.match);
 await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
</CodeGroup>

When sessions are enabled, the plugin will use the `__language_code` property in the session instead of `ctx.from.language_code` (from Telegram client) during language selection.
When your bot sends messages, the locale is selected from `ctx.session.__language_code`.

There is a `setLocale` method that you can use to set the desired language in session.

```ts
await ctx.i18n.setLocale("de");
```

It is equivalent to manually setting it in session and renegotiating the locale:

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

::: tip Renegotiating the Locale

When you are using sessions or something else than `ctx.from.language_code` for selecting a custom locale for the user, there are some situations where you might change the language while handling an update.
For instance, take a look at the above example using sessions.

When you only do

```ts:no-line-numbers
ctx.session.__language_code = "de";
```

It will not update the currently used locale in the i18n instance.
Instead, it only updates the session.
The changes will only take place in the next update.

But you cannot always wait until the next update; you might need to refresh the changes after updating the user language.
Use the `renegotiateLocale` method for these cases.

Now, if we do this

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

Anyplace we use the method `t`, the bot will try to reply with that message's German (`"de"`) translation.

Also, when you use built-in sessions, you can achieve the same result using the `setLocale` method.

:::

::: tip Setting Locale When Not Using Sessions

When [not using sessions](#without-sessions), if there is a case where you need to set the locale for a user, you can do that by using the `useLocale` method.

```ts
await ctx.i18n.useLocale("it");
```

It sets the specified locale to be used for future translations.
The effect lasts only for the current update and is not preserved.
It could be used to change the translation locale in the middle of the update (e.g., when the user changes the language).

:::

## Custom Locale Negotiation

You can use the i18n option `localeNegotiator` if you want to select the local by external sources (like databases) or in other situations where you want to control which locale is used. Here is the default order of the plugin and how it chooses the locale used:

1. If sessions are enabled, try to read `__language_code` from the session.
 If it returns a valid locale, it is used.
 If it returns nothing or a non-registered locale, move on to the second option.
2. Tries to read from `ctx.from.language_code`.
 If it returns a locale that is not registered in the i18n instance, move on to 3rd option.
 Otherwise, it is used.

 If you didn't know before, the `ctx.from.language_code` is only available if the user has started the bot.
 That means if the bot sees the user in a group or somewhere without the user previously starting it, it won't be able to see `ctx.from.language_code`.
3. Default language configured in the i18n options.
4. English (`en`). The plugin itself sets this as the ultimate fallback locale.
 Even though it is a fallback locale and recommended to have a translation, it is not a requirement.
5. If no valid locale is selected, the bot will send `{key}` instead of a translation.
 To avoid broken translations, `defaultLocale` in i18n options should be set to a locale you know exists.

You can easily take control over it using the `localeNegotiator` option in the i18n configuration.

::: tip Locale Negotiation

Locale negotiation happens typically only once during Telegram update processing.
However, you can run `ctx.i18n.renegotiateLocale()` to call the negotiator again and determine the new locale.
This is useful if the locale changes during single update processing.

:::

Here is an example of `localeNegotiator` where we use `locale` from session instead of `__language_code`.
In a case like this, you don't have to set `useSession` to `true` in i18n options.

<CodeGroup>
 <CodeGroupItem title="TypeScript">

```ts
async function myLocaleNegotiator(ctx: Context) {
 return ctx.session.locale ??
 ctx.from?.language_code ??
 "en";
}

const i18n = new I18n({
 localeNegotiator: myLocaleNegotiator,
>>>>>>> Stashed changes
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

<<<<<<< Updated upstream
```js
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
</CodeGroup>

When sessions are enabled, the `__language_code` property in the session will be used instead of `ctx.from.language_code` (from Telegram client) during language selection.
When your bot sends messages, the locale is selected from `ctx.session.__language_code`.

There is a `setLocale` method that you can use to simply set the desired language in session.

```ts
await ctx.i18n.setLocale("de");
```

It is equivalent to manually setting it in session and renegotiating the locale:

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

::: tip Renegotiating the Locale

When you are using sessions or something else than `ctx.from.language_code` for selecting a custom locale for the user, there are some situations where you might change the language during handling an update.
For instance, take a look at the above example using sessions.

When you only do

```ts:no-line-numbers
ctx.session.__language_code = "de";
```

It will not update the currently used locale in the i18n instance.
Instead, it only updates the session.
The changes will only take place in the next update.

But you cannot always wait until the next update, you might need to refresh the changes just after updating the user language.
Use the `renegotiateLocale` method for these cases.

Now if we do this

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

Anyplace we use the method `t`, the bot will try to reply with the German (`"de"`) translation of that message.

Also remember, when you use built-in sessions, you can achieve the same result using the `setLocale` method.

:::

::: tip Setting locale when not using sessions

When [not using sessions](#without-sessions), if there is a case where you need to set the locale for a user, you can do that by using the `useLocale` method.

```ts
await ctx.i18n.useLocale("it");
```

It sets the specified locale to be used for future translations.
The effect lasts only for the duration of the current update and is not preserved.
Could be used to change the translation locale in the middle of the update (e.g. when the user changes the language).

:::

## Custom Locale Negotiation

You can use the i18n option `localeNegotiator` if you want to select the local by external sources (like databases) or other situations where you want to be in control of which locale is used. Here is the default order of the plugin how it chooses the locale used:

1. If sessions are enabled, try to read `__language_code` from the session.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to the second option.
2. Tries to read from `ctx.from.language_code`.
   If it returns a locale that is not registered in the i18n instance move on to 3rd option.
   Otherwise, it is used.

   If you didn't know before, the `ctx.from.language_code` is only available if the user has started the bot.
   That means if the bot sees the user in a group or somewhere without the user previously starting it, it won't be able to see `ctx.from.language_code`.
3. Default language configured in the i18n options.

4. English (`en`). This is set by the plugin itself as the ultimate fallback locale.
   Even though it is a fallback locale and recommended to have a translation, it is not a requirement.
   5. If no valid locale was selected, the bot will send `{key}`, instead of a translation.
   To avoid broken translations, it is **highly recommended** to set a locale that you know exists for sure as `defaultLocale` in i18n options.

You can easily take control over it using the `localeNegotiator` option in the i18n configuration.

::: tip Locale Negotiation

Locale negotiation normally happens only once during Telegram update processing.
However, you can run `ctx.i18n.renegotiateLocale()` to call the negotiator again and determine the new locale.
This is useful if the locale changes during single update processing.

:::

Here is an example of `localeNegotiator` where we use `locale` from session instead of `__language_code`.
In a case like this, you don't have to set `useSession` to `true` in i18n options.

<CodeGroup>
 <CodeGroupItem title="TypeScript">

```ts
async function myLocaleNegotiator(ctx: Context) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```ts
async function myLocaleNegotiator(ctx) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
=======
```ts
async function myLocaleNegotiator(ctx) {
 return ctx.session.locale ??
 ctx.from?.language_code ??
 "en";
}

const i18n = new I18n({
 localeNegotiator: myLocaleNegotiator,
>>>>>>> Stashed changes
});
```

</CodeGroupItem>
</CodeGroup>

If the custom locale negotiator returns an invalid locale, it will fall back and choose a locale with the above order.

## Render Translated Messages

Let's take a closer look at rendering messages.

```ts
bot.command("start", async (ctx) => {
<<<<<<< Updated upstream
  // Call the "translate" or "t" helper to render the
  // message by specifying its ID and additional parameters:
  await ctx.reply(ctx.t("welcome"));
});

bot.command("cart", async (ctx) => {
  // You can pass placeables as the second object.
  await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

Now you can `/start` your bot, it should render the following message:

```:no-line-numbers
Hi there!
=======
 // Call the "translate" or "t" helper to render the
 // message by specifying its ID and additional parameters:
 await ctx.reply(ctx.t("welcome"));
});

bot.command("cart", async (ctx) => {
 // You can pass placeables as the second object.
 await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

Now you can `/start` your bot; it should render the following message:

```:no-line-numbers
Hi there!

>>>>>>> Stashed changes
```

Now, with the `/cart` command:

```:no-line-numbers
You currently have 10 items in your cart.
```

Try to change the value of the `items` variable to see how the rendered message would change!
Consider following fluent doc, the [placeables documentation](https://projectfluent.org/fluent/guide/placeables.html) to find more about them.

## Adding Translations

There are 3 main methods to load translations to the plugin.

### Load Locales Using the `directory` Option

The simplest way to add translations to the i18n instance is by having all of your translations in a directory and specifying them in the i18n options.

```ts
const i18n = new I18n({
<<<<<<< Updated upstream
  directory: "locales",
=======
 directory: "locales",
>>>>>>> Stashed changes
});
```

### Loading Locales From a Directory

This is the same thing as specifying `directory` in options.
Just put them all in a folder and load them like this:

```ts
i18n.loadLocalesDir("locales");
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
```

### Loading a Single Locale

It is also possible to add a single translation to the instance.
You can either specify the file path to the translation like this,

```ts
i18n.loadLocale("en", {
<<<<<<< Updated upstream
  filePath: "path/to/en.ftl",
=======
 filePath: "path/to/en.ftl",
>>>>>>> Stashed changes
});
```

or you can directly load the translation data as a string like this:

```ts
i18n.loadLocale("en", {
<<<<<<< Updated upstream
  source: `greeting = Hello { $first_name }!
=======
 source: `greeting = Hello { $first_name }!
>>>>>>> Stashed changes
language-set = Language has been set to English!`,
});
```

## Custom Placeables and Functions

<<<<<<< Updated upstream
With these two options you can write your translations work. Both are provided by Fluent.
You can read there documentation and see how they are used in the following chapter.
=======
With these two options, you can write your translation work. Fluent provides both.
You can read their documentation and see how they are used in the following chapter.
>>>>>>> Stashed changes

[Placeables](https://projectfluent.org/fluent/guide/placeables.html) and [Functions](https://projectfluent.org/fluent/guide/functions.html) are two core features of the Fluent localization system.
This plugin injects some placeables and functions into your translation context and reduces your work of managing the translation context.

### Placeables

<<<<<<< Updated upstream
Placeables are used to inject data into a translation string.
For example, in a welcome message you may use the name of the user to greet them.
But you can't have messages for each user with their name in your translations.
Instead, you can pass their name in the translation context and the message will change according to the receiver. Here is how you would normally do it:
=======
You use Placeables to inject data into a translation string.
For example, in a welcome message, you may use the user's name to greet them.
But you can't have messages for each user's name in your translations.
Instead, you can pass their name in the translation context, and the message will change according to the receiver. Here is how you would typically do it:
>>>>>>> Stashed changes

`en.ftl`

```fluent:no-line-numbers
welcome = Hi there, { $name }!
```

We can pass a value for the placeable `name`, in the translation context like this:

```ts:no-line-numbers
await ctx.reply(ctx.t("welcome", { name: ctx.from.first_name }))
```

<<<<<<< Updated upstream
Then the message will be different for each user, with their own first names in it.
=======
Then the message will be different for each user, with their first names.
>>>>>>> Stashed changes

#### `first_name`

It is a replacement for `ctx.from.first_name`.
<<<<<<< Updated upstream
So, you don't need to pass it in the context when you need it. You can just use it directly like this
=======
So, you don't need to pass it in the context when you need it. You can use it directly like this.
>>>>>>> Stashed changes

```fluent:no-line-numbers
greeting = Hi { $first_name }
```

### Functions

<<<<<<< Updated upstream
Functions are like placeables. But unlike placables, functions get executed and replaced by the value it returns in the final output.
=======
Functions are like placeables. But unlike placeables, functions get executed and replaced by the value it returns in the final output.
>>>>>>> Stashed changes

#### `CTX`

This function can help you to access any properties of the bot context directly from your translations.

```fluent:no-line-numbers
id = Your user ID: { CTX("from.id") }
```

The `CTX("from.id")` will get replaced by `ctx.from.id`.

Optionally, you can pass in a default value as the second argument.
<<<<<<< Updated upstream
If the value is undefined, the default value is used instead.
=======
If the value is undefined, the default value will be used instead.
>>>>>>> Stashed changes

```fluent:no-line-numbers
id = Last name: { CTX("from.last_name", "You don't have a last name.") }
```

## Listening for Translated Text

We managed to send translated texts to the user.
<<<<<<< Updated upstream
Now imagine, what if the user sends the bot a text?
Yes, we use the `bot.hears` to handle them.
But, what if the user sends a translated version of the text we're trying to listen to?
=======
Now imagine what if the user sends the bot a text?
Yes, we use the `bot.hears` to handle them.
But what if the user sends a translated version of the text we're trying to listen to?
>>>>>>> Stashed changes
This plugin also makes this part easy for you.

```ts
bot.hears("Hello", async (ctx) => {
<<<<<<< Updated upstream
  // handle update
});
bot.hears("Hallo", async (ctx) => {
  // handle update
=======
 // handle update
});
bot.hears("Hallo", async (ctx) => {
 // handle update
>>>>>>> Stashed changes
});
```

If those handlers are the same, we could do this:

```ts
bot.hears(["Hello", "Hallo"], async (ctx) => {
<<<<<<< Updated upstream
  // handle update
});
```

But, it is kind of hard to list out all the translations to listen for.
=======
 // handle update
});
```

But, it is hard to list all the translations to listen for.
>>>>>>> Stashed changes
With the `t` method from the i18n instance, you can do this:

```ts
bot.hears(i18n.t("welcome-text"), async (ctx) => {
<<<<<<< Updated upstream
  // handle update
=======
 // handle update
>>>>>>> Stashed changes
});
```

::: warning

Make sure to load all of the translations before using this method.
Otherwise, you cannot listen to all of the translations.

:::

## Further Steps

- Complete reading the [Fluent documentation](https://projectfluent.org/), especially the [syntax guide](https://projectfluent.org/fluent/guide/).
<<<<<<< Updated upstream
- Check out proper [examples](https://github.com/grammyjs/i18n/tree/main/examples) of this plugin for Deno and Node.
=======
- Check out proper [examples](https://github.com/grammyjs/i18n/tree/main/examples) for Deno and Node.
>>>>>>> Stashed changes

## Plugin Summary

- Name: `i18n`
- Source: <https://github.com/grammyjs/i18n>
- API Reference: <https://doc.deno.land/https://deno.land/x/grammy_i18n/mod.ts>
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
