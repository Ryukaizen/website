# Internationalization

When you need to target a multi-language audience with your bot, you're going to need internationalization.
grammY's i18n plugin can help you add multiple languages to your bot as easily as possible.

The i18n plugin is built on top of [Fluent](https://projectfluent.org/).
Fluent is a localization system for natural-sounding translations made by the Mozilla Foundation.
It has a very powerful and elegant syntax that lets anyone write efficient and fully understandable translations.
This plugin takes advantage of this amazing localization system to make bots powered by grammY fluent with high-quality translations.

## Getting Started

There are [several ways](#adding-translations) to add translations to the bot.
The quickest of them all is having all the translation files in a directory and loading that directory.
Usually, the name of that folder is going to be `locales/`.
The translation file's name should have the extension `.ftl` (fluent).

Here is an example project structure:

```asciiart:no-line-numbers
.
├─ locales/
│  ├── en.ftl
│  ├── it.ftl
│  ├── de.ftl
│  └── ru.ftl
└── bot.ts
```

If you're unfamiliar with the Fluent file (`.ftl`) syntax, you can have a look at their syntax guide: <https://projectfluent.org/fluent/guide>

These translation files contain translations like this:

`en.ftl`

```fluent
start = Hi, how can I /help you?
help = 
    Send me some text and I can make it bold for you.
    You can also change my language using the /language command.
```

`ru.ftl`

```fluent
start = (RU) Hi, how can I /help you?
help = 
    (RU) Send me a text message. I can make it bold for you.
    You can also change my language using the /language command.
```

Here is how you can show them to the user:

```ts
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
  await ctx.reply(ctx.t("help"));
});
```

Whenever a message is sent, the best possible translation is selected for the user.
So as a result, different users with different languages will be able to read the messages in their languages.

## Usage

Assuming that you have set up translations, let's see how we can effectively use them in our bot.

For the best possible language experience for the user, a perfect locale (translation) should be selected before sending a message.
This could be decided based on the user's `language_code` we receive from Telegram updates.
Or even better, if your bot has a command for changing the language, it is better to use the language which the user has selected.
Based on these different language selection approaches, the i18n plugin can be configured mainly in two different ways: [With](#with-sessions) or [Without sessions](#without-sessions).

Continue reading to find out which is best for your use case.

### Without Sessions

This is easier to set up and use than using with sessions.
But this will not directly allow you to control the language selection.
(Though technically, you can just implement a [custom locale negotiator](#custom-locale-negotiation) to achieve that).

The locale for the user is selected from `ctx.from.language_code`, which is the language code of the user.
But if you don't have a translation of that language, the default language will be used.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

// For full TypeScript support and proper auto-completion
// extend the Context with I18n's Context Flavor.
type MyContext = Context & I18nContextFlavor;

// Create a bot as you would normally do. But
// remember to use the extended Context like this.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an I18n instance. Continue reading
// to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // See below for more information.

  // Load all translation files from the `locales` folder.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n.middleware());

// Everything is set up now. You can access translations
// with the `t` or `translate` methods.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

// Create a bot as you would normally do.
const bot = new Bot(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an I18n instance. Continue reading
// to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // See below for more information.

  // Load all translation files from the `locales` folder.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n.middleware());

// Everything is set up now. You can access translations
// with the `t` or `translate` methods.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

// For full TypeScript support and proper auto-completion
// extend the Context with I18n's Context Flavor.
type MyContext = Context & I18nContextFlavor;

// Create a bot as you would normally do. But
// remember to use the extended Context like this.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an I18n instance. Continue reading
// to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // See below for more information.

  // Load all translation files from the `locales` folder.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now. You can access translations
// with the `t` or `translate` methods.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
</CodeGroup>

`ctx.t` returns the translated message for the specified key.
You don't have to worry about languages here.

That's it, congratulations.
Your bot is a polyglot :tada:

### With Sessions

As mentioned earlier, let's say your bot has a `/language` command that a user can use to configure their interface language.
Generally in grammY, we can make use of [sessions](./session.md) to read and write user data.
Like that, we can use sessions to store a user's language and use it to reply to messages in that language.
To let your i18n instance know that sessions are enabled, you have to set `useSession` to `true` in the i18n options.

Here is an example of implementing it, including a simple `/language` command:

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n.middleware());

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n.middleware());

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n.middleware());

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
</CodeGroup>

When sessions are enabled, the `__language_code` property in the session has a higher priority than `ctx.from.language_code` during language selection.
When your bot sends messages, the locale is selected from `ctx.session.__language_code`.

And as you may have noticed in the above example, there is a `setLocale` method that you can use to simply set the desired language in session.
It is equivalent to manually setting it in session and renegotiating the locale:

```ts
ctx.session.__language_code = "ru";
await ctx.i18n.renegotiateLocale();
```

::: tip Renegotiating the locale

When you are using sessions or something else than `ctx.from.language_code` for selecting a custom locale for the user, there are some situations where you might change the language during handling an update.
For instance, take a look at the above example using sessions. There we are changing the locale in session.

When you only do

```ts:no-line-numbers
ctx.session.__language_code = "ru";
```

it will not update the currently using locale in the i18n instance.
Instead, it only updates the session.
The changes will only take place in the next update.

But you cannot always wait until the next update, you might need to refresh the changes just after updating the user language.
That is why the `renegotiateLocale` method exists.

Now if we do this

```ts
ctx.session.__language_code = "ru";
await ctx.i18n.renegotiateLocale();
```

anyplace we use the method `t`, the bot will try to reply with the Russian (`"ru"`) translation of that message.

Also remember, when you use built-in sessions, you can achieve the same result using the `setLocale` method.

:::

::: tip Setting locale when not using sessions

When [not using sessions](#without-sessions), if there is a case where you need to set the locale for a user, you can do that by using the `useLocale` method.

```ts
await ctx.i18n.useLocale("it");
```

It sets the specified locale to be used for future translations.
The effect lasts only for the duration of the current update and is not preserved.
Could be used to change the translation locale in the middle of the update (e.g. when the user changes the language).

:::

## Custom Locale Negotiation

We already saw how to configure the i18n instance with and without sessions.
Here is how the plugin chooses the most appropriate language for the user:

1. If sessions are enabled, try to read `__language_code` from the session.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to the second option.
2. Tries to read from `ctx.from.language_code`.
   If it returns a locale that is not registered in the i18n instance move on to 3rd option.
   Otherwise, it is used.

   If you didn't know before, the `ctx.from.language_code` is only available if the user has started the bot.
   That means if the bot sees the user in a group or somewhere without the user previously starting it, it won't be able to see `ctx.from.language_code`.
3. Default language configured in the i18n options.
   We **highly recommend** you set `defaultLocale` to a language that you know exists for sure.
   So the bot won't send `{key}` to the user instead of a proper message while running in production.
4. English (`en`). This is set by the plugin itself as the ultimate fallback locale.
   Even though it is a fallback locale and recommended to have a translation, it is not a requirement.

While this order is great, there could be another situation where you need to take control over the language selection.
Maybe you need to set the locale you got from some other sources.
You can easily take control over it using the `localeNegotiator` option in the i18n configuration.

::: tip Locale Negotiation

Locale negotiation normally happens only once during Telegram update processing.
However, you can call `ctx.i18n.renegotiateLocale()` to call the negotiator again and determine the new locale.
This is useful if the locale changes during single update processing.

:::

Here is an example of `localeNegotiator` where we use `locale` from session instead of `__language_code`.
In a case like this, you don't have to set `useSession` to `true` in i18n options.

```ts
async function myLocaleNegotiator(ctx: Context) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
});
```

If the custom locale negotiator returns an invalid locale, it will fall back and choose a locale with the above order.

## Render Translated Messages

Let's take a closer look at rendering messages.

```ts
bot.command("start", async (ctx) => {
  // Call the "translate" or "t" helper to render the
  // message by specifying its ID and additional parameters:
  await ctx.reply(ctx.t("welcome"));
});

bot.command("cart", async (ctx) => {
  // You can pass placeables as the second object.
  await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

Now you can `/start` your bot, it should render the following message:

```:no-line-numbers
Hi there!
```

Now, with the `/cart` command:

```:no-line-numbers
You currently have 10 items in your cart.
```

Try to change the value of the `items` variable to see how the rendered message would change!
Consider following the [placeables official documentation](https://projectfluent.org/fluent/guide/placeables.html) to find more about them.

## Adding Translations

There are several methods to add translations to the plugin.

### Load Locales Using the `directory` Option

The simplest way to add translations to the i18n instance is by having all of your translations in a directory and specifying them in the i18n options.

```ts
const i18n = new I18n({
  directory: "locales",
});
```

### Loading Locales From a Directory

This is the same thing as specifying `directory` in options.
Just put them all in a folder and load them like this:

```ts
i18n.loadLocalesDir("locales");
```

### Loading a Single Locale

It is also possible to add a single translation to the instance.
You can either specify the file path to the translation like this,

```ts
i18n.loadLocale("en", {
  filePath: "path/to/en.ftl",
});
```

or you can directly load the translation data as a string like this:

```ts
i18n.loadLocale("en", {
  source: `greeting = Hello { $first_name }!
language-set = Language has been set to English!`,
});
```

## Custom Placeables and Functions

So, far we saw how to make the bot talk in different languages.
Now let's take a look at how this plugin helps you to write the translations faster.

[Placeables](https://projectfluent.org/fluent/guide/placeables.html) and [Functions](https://projectfluent.org/fluent/guide/functions.html) are two core features of the Fluent localization system.
This plugin injects some placeables and functions into your translation context and reduces your work of managing the translation context.

### Placeables

#### `first_name`

It is a replacement for `ctx.from.first_name`.
So, you don't need to pass it in the context when you need it. You can just use it directly like this

```fluent
greeting = Hi { $first_name }
```

### Functions

#### `CTX`

This function can help you to access any properties of the bot context directly from your translations. Here is how

```fluent
id = Your user ID: { CTX("from.id") }
```

The `CTX("from.id")` will get replaced by `ctx.from.id`.

Optionally, you can pass in a default value as the second argument.
If the value is undefined, the default value is used instead.

```fluent
id = Last name: { CTX("from.last_name", "You don't have a last name.") }
```

## Listening for Translated Text

We managed to send translated texts to the user.
Now imagine, what if the user sends the bot a text?
Yes, we use the `bot.hears` to handle them.
But, what if the user sends a translated version of the text we're trying to listen to?
This plugin also makes it easy for you.

```ts
bot.hears("Hello", async (ctx) => {
  // handle update
});
bot.hears("Hallo", async (ctx) => {
  // handle update
});
```

If those handlers are the same, we could do this:

```ts
bot.hears(["Hello", "Hallo"], async (ctx) => {
  // handle update
});
```

But, it is kind of hard to list out all the translations to listen for.
With the `t` method from the i18n instance, you can do this:

```ts
bot.hears(i18n.t("welcome-text"), async (ctx) => {
  // handle update
});
```

::: warning

Make sure to load all of the translations before using this method.
Otherwise, you cannot listen to all of the translations.

:::

## Further Steps

- Complete reading the [Fluent documentation](https://projectfluent.org/), especially the [syntax guide](https://projectfluent.org/fluent/guide/).
- Check out proper [examples](https://github.com/grammyjs/i18n/tree/main/examples) for Deno and Node.

## Plugin Summary

- Name: `i18n`
- Source: <https://github.com/grammyjs/i18n>
- API Reference: <https://doc.deno.land/https://deno.land/x/grammy_i18n/mod.ts>
