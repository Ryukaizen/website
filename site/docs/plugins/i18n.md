# Internationalization (`i18n`)

The internationalization plugin helps you with writing a bot that can speak multiple languages.

## Internationalization Explained

> This part explains what internationalization is, why it's needed, what is difficult about it, how it relates to localization, and why you need a plugin for all of this.
> If you already know these things, scroll down in order to [get started](#getting-started).

First of all: internationalization is a very long word, so people like to write the first letter (i) and the last letter (n).
They then count all remaining letters (nternationalizatio, 18 letters) and put this number between the i and the n, so they end up with _i18n_.
Don't ask us why.
So i18n really is just a weird abbreviation of the word internationalization.

The same is done to localization, which turns into _l10n_.

### What Is Localization?

Localization means to create a bot that can speak multiple languages.
It should automatically adjust its language to the language of the user.

There are in fact more things to localize than the language
You can also account for cultural differences, or other standards, such as date and time formats.
Here are a few more examples of things that are represented differently across the globe:

1. Dates
2. Times
3. Numbers
4. Units
5. Pluralization
6. Genders
7. Hyphenation
8. Capitalization
9. Alignment
10. Symbols and icons
11. Sorting

… and [a lot more](https://youtu.be/0j74jcxSunY).

All of these things collectively define the _locale_ of a user.
Locales often get two-letter codes, such as `en` for English, `de` for German, and so on.

### What Is Internationalization?

In a nutshell, doing internationalization means writing code that can adjust to the locale of a user.
In other words, internationalization is what enables localization (see [above](#what-is-localization)).
This means that while your bot fundamentally works the same way for everybody, the exact messages it sends vary from user to user, so that the bot can speak different languages.

If you don't hard-code the texts your bot sends, but rather read them from a file dynamically, you are doing internationalization.
If you don't hard-code how dates and times are represented, but rather use a library that adjust these values to different standards, you are doing internationalization.
You get the idea: don't hard-code stuff that should change based on where the user lives, or the language they speak.

### Why Do You Need This Plugin?

This plugin can assist you with internationalization.
It is based on [Fluent](https://projectfluent.org/)—an excellent localization system built by [Mozilla](https://mozilla.org/).
This system has a very powerful and elegant syntax that lets you write natural-sounding translations efficiently.

In essence, you can extract the things that should adjust based on the user's locale to some text files that you put next to your code.
You can then use this plugin to load these localizations.
The plugin will automatically determine the locale of the user and make your bot speak the right language.

In the following, we will call these text files _translation files_.
They need to follow the syntax of Fluent.

## Getting Started

> This section describes how to set up your project structure and where to put your translation files.
> If you are familiar with this, [skip ahead](#usage) to see how to install and use the plugin.

There are [multiple ways](#adding-translations) to add more languages to your bot.
The easiest way is to create a folder with your Fluent translation files in it.
Usually, the name of that folder is going to be `locales/`.
The translation files should have the extension `.ftl` (fluent).

Here is an example project structure:

```asciiart:no-line-numbers
.
├── bot.ts
└── locales/
    ├── de.ftl
    ├── en.ftl
    ├── it.ftl
    └── ru.ftl
```

If you're unfamiliar with the Fluent file (`.ftl`) syntax, you can have a look at their syntax guide here: <https://projectfluent.org/fluent/guide>

Here is an example translation file for English, called `locales/en.ftl`:

```fluent
start = Hi, how can I /help you?
help = 
    Send me some text and I can make it bold for you.
    You can change my language using the /language command.
```

The German equivalent would be called `locales/de.ftl` and look like this:

```fluent
start = Hallo, wie kann ich dir helfen? /help
help = 
    Schick eine Textnachricht, die ich für dich fett schreiben soll.
    Du kannst mit dem Befehl /language die Spache ändern.
```

In your bot, you can now use these translations through this plugin.
It will make them available through `ctx.t`:

```ts
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
  await ctx.reply(ctx.t("help"));
});
```

Whenever you call `ctx.t`, the locale of the current context object `ctx` is used in order to find the right translation.
This is done using a function that is called _locale negotiator_.
In the simplest case, it just returns `ctx.from.language_code`.

As a result, different users with different locales will be able to read the messages each in their own language.

## Usage

The plugin derives the user's locale from many different factors.
One of them is the value of `ctx.from.language_code` provided by the Telegram client of the user.

However, there are many more things that can be used to determine the locale of the user.
For example, you could store the locale of the user in your [session](./session.md).
Hence, there are two main ways to use this plugin: [with sessions](#with-sessions) or [without sessions](#without-sessions).

### Without Sessions

This is easier to set up and use than using with sessions.
Its main drawback is that you can’t save the chosen language of the user.

The locale for the user is selected based on `ctx.from.language_code`, which is provided by the Telegram client of the user.
But if you don't have a translation of that language, the default language will be used.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

// For full TypeScript support and proper auto-completion
// extend the Context with I18n's Context Flavor.
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

// Create a bot as you normally would.
const bot = new Bot(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

// For TypeScript and auto-completion support,
// extend the context with I18n's flavor:
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
</CodeGroup>

`ctx.t` returns the translated message for the specified key.
You don't have to worry about languages, as they will be picked automatically by the plugin.

Congratulations!
Your bot now speaks multiple languages! :earth_africa::tada:

### With Sessions

Let's assume again that your bot has a `/language` command.
Generally in grammY, we can make use of [sessions](./session.md) to store user data per chat.
In order to let your internationalization instance know that sessions are enabled, you have to set `useSession` to `true` in the options of `I18n`.

Here is an example, including a simple `/language` command:

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether to store user language in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
</CodeGroup>

When sessions are enabled, the `__language_code` property in the session will be used instead of `ctx.from.language_code` (provided by the Telegram client) during language selection.
When your bot sends messages, the locale is selected from `ctx.session.__language_code`.

There is a `setLocale` method that you can use to simply set the desired language.
It will save this value in your session.

```ts
await ctx.i18n.setLocale("de");
```

This is equivalent to manually setting it in session, and then renegotiating the locale:

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

::: tip Renegotiating the Locale

When you are using sessions or something else---apart from `ctx.from.language_code`---for selecting a custom locale for the user, there are some situations where you might change the language during the handling of an update.
For instance, take a look at the above example using sessions.

When you only do

```ts:no-line-numbers
ctx.session.__language_code = "de";
```

it will not update the currently used locale in the i18n instance.
Instead, it only updates the session.
Thus, the changes will only take place _for the next update_.

If you cannot wait until the next update, you might need to refresh the changes just after updating the user language.
Use the `renegotiateLocale` method for these cases.

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

Anyplace we use the method `t`, the bot will try to reply with the German translation of that message (specified in `locales/de.ftl`).

Also remember that when you use built-in sessions, you can achieve the same result using the `setLocale` method.

:::

::: tip Setting the Locale When Not Using Sessions

When [not using sessions](#without-sessions), if there is a case where you need to set the locale for a user, you can do that by using the `useLocale` method.

```ts
await ctx.i18n.useLocale("de");
```

It sets the specified locale to be used for future translations.
The effect lasts only for the duration of the current update and is not preserved.
This can be used to change the translation locale in the middle of the update (e.g. when the user changes the language).

:::

## Custom Locale Negotiation

You can use the option `localeNegotiator` in order to specify a custom locale negotiator.
This is useful if you want to select the locale based on external sources (such as databases), or in other situations where you want to be in control of which locale is used.

Here is the default order of how the plugin chooses its locale:

1. If sessions are enabled, try to read `__language_code` from the session.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to step 2.
2. Try to read from `ctx.from.language_code`.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to step 3.

   > Note that `ctx.from.language_code` is only available if the user has started the bot.
   > That means if the bot sees the user in a group or somewhere without the user previously having started the bot, it won't be able to see `ctx.from.language_code`.
3. Try using the default language configured in the options of `I18n`.
   If it set to a valid locale, it is used.
   If it isn't specified or set to a non-registered locale, move on to step 4.
4. English (`en`). This is set by the plugin itself as the ultimate fallback locale.
   Even though it is a fallback locale and we recommend to have a translation for it, it is not a requirement.
   If no English locale is provided, move on to step 5.
5. If all above things fail, use `{key}` instead of a translation.
   To avoid broken translations, it is **highly recommended** to set a locale that you know exists for sure as `defaultLocale` in i18n options.

::: tip Locale Negotiation

Locale negotiation normally happens only once during Telegram update processing.
However, you can run `ctx.i18n.renegotiateLocale()` to call the negotiator again and determine the new locale.
This is useful if the locale changes during single update processing.

:::

Here is an example of `localeNegotiator` where we use `locale` from session instead of `__language_code`.
In a case like this, you don't have to set `useSession` to `true` in i18n options.

<CodeGroup>
 <CodeGroupItem title="TypeScript">

```ts
async function myLocaleNegotiator(ctx: Context) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```ts
async function myLocaleNegotiator(ctx) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
});
```

</CodeGroupItem>
</CodeGroup>

If the custom locale negotiator returns an invalid locale, it will fall back and choose a locale, following the above order.

## Rendering Translated Messages

Let's take a closer look at rendering messages.

```ts
bot.command("start", async (ctx) => {
  // Call the "translate" or "t" helper to render the
  // message by specifying its ID and additional parameters:
  await ctx.reply(ctx.t("welcome"));
});

bot.command("cart", async (ctx) => {
  // You can pass placeables as the second object.
  await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

Now you can `/start` your bot, it should render the following message:

```:no-line-numbers
Hi there!
```

Now, with the `/cart` command:

```:no-line-numbers
You currently have 10 items in your cart.
```

Try to change the value of the `items` variable to see how the rendered message would change!
Also check out the Fluent documentation, and especially the [placeables documentation](https://projectfluent.org/fluent/guide/placeables.html).

## Adding Translations

There are three main methods to load translations.

### Loading Locales Using the `directory` Option

The simplest way to add translations to the `I18n` instance is by having all of your translations in a directory, and specifying the directory name in the options.

```ts
const i18n = new I18n({
  directory: "locales",
});
```

### Loading Locales From a Directory

This is the same thing as specifying `directory` in options.
Just put them all in a folder and load them like this:

```ts
const i18n = new I18n();
await i18n.loadLocalesDir("locales");
```

### Loading a Single Locale

It is also possible to add a single translation to the instance.
You can either specify the file path to the translation using

```ts
const i18n = new I18n();
await i18n.loadLocale("en", {
  filePath: "locales/en.ftl",
});
```

or you can directly load the translation data as a string like this:

```ts
const i18n = new I18n();
await i18n.loadLocale("en", {
  source: `greeting = Hello { $first_name }!
language-set = Language has been set to English!`,
});
```

## Custom Placeables and Functions

These two features are going to help you when translating things.
Both are provided by Fluent.
You can read there documentation and see how they are used in the following chapter.

[Placeables](https://projectfluent.org/fluent/guide/placeables.html) and [Functions](https://projectfluent.org/fluent/guide/functions.html) are two core features of the Fluent localization system.
This plugin injects some placeables and functions into your translation context and reduces your work of managing the translation context.

### Placeables

Placeables are used to inject data into a translation string.
For example, in a welcome message you may use the name of the user to greet them.
But you can't have messages for each user with their name in your translations.
Instead, you can pass their name in the translation context and the message will change according to the receiver.

Here is what you would do in `en.ftl`:

```fluent:no-line-numbers
welcome = Hi there, { $name }!
```

We can pass a value for the placeable `name`, in the translation context like this:

```ts:no-line-numbers
await ctx.reply(ctx.t("welcome", { name: ctx.from.first_name }))
```

Then the message will be different for each user, with their own first names in it.

#### `first_name`

It is a replacement for `ctx.from.first_name`.
So, you don't need to pass it in the context when you need it. You can just use it directly like this

```fluent:no-line-numbers
greeting = Hi { $first_name }
```

### Functions

Functions are like placeables. But unlike placables, functions get executed and replaced by the value it returns in the final output.

#### `CTX`

This function can help you to access any properties of the bot context directly from your translations.

```fluent:no-line-numbers
id = Your user ID: { CTX("from.id") }
```

The `CTX("from.id")` will get replaced by `ctx.from.id`.

Optionally, you can pass in a default value as the second argument.
If the value is undefined, the default value is used instead.

```fluent:no-line-numbers
id = Last name: { CTX("from.last_name", "You don't have a last name.") }
```

## Listening for Translated Text

We managed to send translated texts to the user.
Now imagine, what if the user sends the bot a text?
Yes, we use the `bot.hears` to handle them.
But, what if the user sends a translated version of the text we're trying to listen to?
This plugin also makes this part easy for you.

```ts
bot.hears("Hello", async (ctx) => {
  // handle update
});
bot.hears("Hallo", async (ctx) => {
  // handle update
});
```

If those handlers are the same, we could do this:

```ts
bot.hears(["Hello", "Hallo"], async (ctx) => {
  // handle update
});
```

But, it is kind of hard to list out all the translations to listen for.
With the `t` method from the i18n instance, you can do this:

```ts
bot.hears(i18n.t("welcome-text"), async (ctx) => {
  // handle update
});
```

::: warning

Make sure to load all of the translations before using this method.
Otherwise, you cannot listen to all of the translations.

:::

## Further Steps

- Complete reading the [Fluent documentation](https://projectfluent.org/), especially the [syntax guide](https://projectfluent.org/fluent/guide/).
- Check out proper [examples](https://github.com/grammyjs/i18n/tree/main/examples) of this plugin for Deno and Node.

## Plugin Summary

- Name: `i18n`
- Source: <https://github.com/grammyjs/i18n>
- API Reference: <https://doc.deno.land/https://deno.land/x/grammy_i18n/mod.ts>
