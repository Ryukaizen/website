# Internationalization

The i18n plugin helps you with providing multiple languages for your bot. It does this by loading translation files from a directory or directly by providing the string via the loadLocale methods source option.
The plugin is based on [Fluent](https://projectfluent.org/)—a localization framework supported by [Mozilla](https://mozilla.org/).
It has a very powerful and elegant syntax that lets anyone write efficient and natural-sounding translations.

## Getting Started

There are [multiple ways](#adding-translations) to add more languages to your bot.
The easiest way is creating a folder with your fluent translation files in it.
Usually, the name of that folder is going to be `locales/`.
The translation files should have the extension `.ftl` (fluent).

Here is an example project structure:

```asciiart:no-line-numbers
.
├── bot.ts
└── locales/
    ├── de.ftl
    ├── en.ftl
    ├── it.ftl
    └── ru.ftl
```

If you're unfamiliar with the Fluent file (`.ftl`) syntax, you can have a look at their syntax guide here: <https://projectfluent.org/fluent/guide>

These translation files contain translations like this:

`en.ftl`

```fluent
start = Hi, how can I /help you?
help = 
    Send me some text and I can make it bold for you.
    You can change my language using the /language command.
```

`de.ftl`

```fluent
start = Hallo, wie kann ich dir helfen? /help
help = 
    Schick eine Textnachricht, die ich für dich fett schreiben soll.
    Du kannst mit dem Befehl /language die Spache ändern.
```

Using the translations in your bot:

```ts
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start"));
});

bot.command("help", async (ctx) => {
  await ctx.reply(ctx.t("help"));
});
```

Whenever a message is sent the locale of context is used.
This could be your specific language negotiator or just `ctx.from.language_code`
So as a result different users with different locales will be able to read the messages in their languages.

## Usage

The plugin chooses the language in use by different ways. One of them is the default `ctx.from.language_code` provided by the Telegram client of the user.
If your bot has a command for changing the language it is better to use the language chosen by the user.
Based on these different language selection approaches the i18n plugin can be configured mainly in two different ways: [With sessions](#with-sessions) or [Without sessions](#without-sessions).

### Without Sessions

This is easier to set up and use than using with sessions. Its main drawback is that you can’t save the chosen language of the user.
Though technically, you can just implement a [custom locale negotiator](#custom-locale-negotiation) to achieve that.

The locale for the user is selected from `ctx.from.language_code`, which is provided by the Telegram client of the user.
But if you don't have a translation of that language, the default language will be used.

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

// For full TypeScript support and proper auto-completion
// extend the Context with I18n's Context Flavor.
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

// Create a bot as you normally would.
const bot = new Bot(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import { Bot, Context } from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

// For TypeScript and auto-completion support,
// extend the context with I18n's flavor:
type MyContext = Context & I18nContextFlavor;

// Create a bot as you normally would.
// Remember to extend the context.
const bot = new Bot<MyContext>(""); // <-- put your bot token here (https://t.me/BotFather)

// Create an `I18n` instance.
// Continue reading to find out how to configure the instance.
const i18n = new I18n({
  defaultLocale: "en", // see below for more information

  // Load all translation files from locales/.
  directory: "locales",
});

// Finally, register the i18n instance in the bot,
// so the messages get translated on their way!
bot.use(i18n);

// Everything is set up now.
// You can access translations with `t` or `translate`.
bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("start-msg"));
});
```

</CodeGroupItem>
</CodeGroup>

`ctx.t` returns the translated message for the specified key.
You don't have to worry about languages here.

Your bot is a polyglot :tada:

### With Sessions

As mentioned earlier, let's assume your bot has a `/language` command.
Generally in grammY, we can make use of [sessions](./session.md) to read and write user data.
To let your i18n instance know that sessions are enabled, you have to set `useSession` to `true` in the i18n options.

An example of implementing it, including a simple `/language` command:

<CodeGroup>
  <CodeGroupItem title="TypeScript" active>

```ts
import { Bot, Context, session, SessionFlavor } from "grammy";
import { I18n, I18nContextFlavor } from "@grammyjs/i18n";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether to store user language in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```js
const { Bot, session } = require("grammy");
const { I18n } = require("@grammyjs/i18n");

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
 <CodeGroupItem title="Deno">

```ts
import {
  Bot,
  Context,
  session,
  SessionFlavor,
} from "https://deno.land/x/grammy/mod.ts";
import {
  I18n,
  I18nContextFlavor,
} from "https://deno.land/x/grammy_i18n/mod.ts";

interface SessionData {
  __language_code?: string;
}

type MyContext =
  & Context
  & SessionFlavor<SessionData>
  & I18nContextFlavor;

const i18n = new I18n({
  defaultLocale: "en",
  useSession: true, // whether get/set in session

  // Load locales from the `locales` directory.
  directory: "locales",
});

const bot = new Bot<MyContext>(""); // <-- put your bot token here

// Remember to register `session` middleware before
// registering middleware of the i18n instance.
bot.use(session({
  initial: () => {
    return {};
  },
}));

// Register i18n middleware
bot.use(i18n);

bot.command("start", async (ctx) => {
  await ctx.reply(ctx.t("greeting"));
});

bot.command("language", async (ctx) => {
  if (ctx.match === "") {
    return await ctx.reply(ctx.t("language.specify-a-locale"));
  }

  // `i18n.locales` contains all the locales that have been registered
  if (!i18n.locales.includes(ctx.match)) {
    return await ctx.reply(ctx.t("language.invalid-locale"));
  }

  // `ctx.i18n.getLocale` returns the locale currently using.
  if (await ctx.i18n.getLocale() === ctx.match) {
    return await ctx.reply(ctx.t("language.already-set"));
  }

  await ctx.i18n.setLocale(ctx.match);
  await ctx.reply(ctx.t("language.language-set"));
});
```

</CodeGroupItem>
</CodeGroup>

When sessions are enabled, the `__language_code` property in the session will be used instead of `ctx.from.language_code` (from Telegram client) during language selection.
When your bot sends messages, the locale is selected from `ctx.session.__language_code`.

There is a `setLocale` method that you can use to simply set the desired language in session.

```ts
await ctx.i18n.setLocale("de");
```

It is equivalent to manually setting it in session and renegotiating the locale:

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

::: tip Renegotiating the Locale

When you are using sessions or something else than `ctx.from.language_code` for selecting a custom locale for the user, there are some situations where you might change the language during handling an update.
For instance, take a look at the above example using sessions.

When you only do

```ts:no-line-numbers
ctx.session.__language_code = "de";
```

It will not update the currently used locale in the i18n instance.
Instead, it only updates the session.
The changes will only take place in the next update.

But you cannot always wait until the next update, you might need to refresh the changes just after updating the user language.
Use the `renegotiateLocale` method for these cases.

Now if we do this

```ts
ctx.session.__language_code = "de";
await ctx.i18n.renegotiateLocale();
```

Anyplace we use the method `t`, the bot will try to reply with the German (`"de"`) translation of that message.

Also remember, when you use built-in sessions, you can achieve the same result using the `setLocale` method.

:::

::: tip Setting locale when not using sessions

When [not using sessions](#without-sessions), if there is a case where you need to set the locale for a user, you can do that by using the `useLocale` method.

```ts
await ctx.i18n.useLocale("it");
```

It sets the specified locale to be used for future translations.
The effect lasts only for the duration of the current update and is not preserved.
Could be used to change the translation locale in the middle of the update (e.g. when the user changes the language).

:::

## Custom Locale Negotiation

You can use the i18n option `localeNegotiator` if you want to select the local by external sources (like databases) or other situations where you want to be in control of which locale is used. Here is the default order of the plugin how it chooses the locale used:

1. If sessions are enabled, try to read `__language_code` from the session.
   If it returns a valid locale, it is used.
   If it returns nothing or a non-registered locale, move on to the second option.
2. Tries to read from `ctx.from.language_code`.
   If it returns a locale that is not registered in the i18n instance move on to 3rd option.
   Otherwise, it is used.

   If you didn't know before, the `ctx.from.language_code` is only available if the user has started the bot.
   That means if the bot sees the user in a group or somewhere without the user previously starting it, it won't be able to see `ctx.from.language_code`.
3. Default language configured in the i18n options.

4. English (`en`). This is set by the plugin itself as the ultimate fallback locale.
   Even though it is a fallback locale and recommended to have a translation, it is not a requirement.
   5. If no valid locale was selected, the bot will send `{key}`, instead of a translation.
   To avoid broken translations, it is **highly recommended** to set a locale that you know exists for sure as `defaultLocale` in i18n options.

You can easily take control over it using the `localeNegotiator` option in the i18n configuration.

::: tip Locale Negotiation

Locale negotiation normally happens only once during Telegram update processing.
However, you can run `ctx.i18n.renegotiateLocale()` to call the negotiator again and determine the new locale.
This is useful if the locale changes during single update processing.

:::

Here is an example of `localeNegotiator` where we use `locale` from session instead of `__language_code`.
In a case like this, you don't have to set `useSession` to `true` in i18n options.

<CodeGroup>
 <CodeGroupItem title="TypeScript">

```ts
async function myLocaleNegotiator(ctx: Context) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
});
```

</CodeGroupItem>
 <CodeGroupItem title="JavaScript">

```ts
async function myLocaleNegotiator(ctx) {
  return ctx.session.locale ??
    ctx.from?.language_code ??
    "en";
}

const i18n = new I18n({
  localeNegotiator: myLocaleNegotiator,
});
```

</CodeGroupItem>
</CodeGroup>

If the custom locale negotiator returns an invalid locale, it will fall back and choose a locale with the above order.

## Render Translated Messages

Let's take a closer look at rendering messages.

```ts
bot.command("start", async (ctx) => {
  // Call the "translate" or "t" helper to render the
  // message by specifying its ID and additional parameters:
  await ctx.reply(ctx.t("welcome"));
});

bot.command("cart", async (ctx) => {
  // You can pass placeables as the second object.
  await ctx.reply(ctx.t("cart-msg", { items: 10 }));
});
```

Now you can `/start` your bot, it should render the following message:

```:no-line-numbers
Hi there!
```

Now, with the `/cart` command:

```:no-line-numbers
You currently have 10 items in your cart.
```

Try to change the value of the `items` variable to see how the rendered message would change!
Consider following fluent doc, the [placeables documentation](https://projectfluent.org/fluent/guide/placeables.html) to find more about them.

## Adding Translations

There are 3 main methods to load translations to the plugin.

### Load Locales Using the `directory` Option

The simplest way to add translations to the i18n instance is by having all of your translations in a directory and specifying them in the i18n options.

```ts
const i18n = new I18n({
  directory: "locales",
});
```

### Loading Locales From a Directory

This is the same thing as specifying `directory` in options.
Just put them all in a folder and load them like this:

```ts
i18n.loadLocalesDir("locales");
```

### Loading a Single Locale

It is also possible to add a single translation to the instance.
You can either specify the file path to the translation like this,

```ts
i18n.loadLocale("en", {
  filePath: "path/to/en.ftl",
});
```

or you can directly load the translation data as a string like this:

```ts
i18n.loadLocale("en", {
  source: `greeting = Hello { $first_name }!
language-set = Language has been set to English!`,
});
```

## Custom Placeables and Functions

With these two options you can write your translations work. Both are provided by Fluent.
You can read there documentation and see how they are used in the following chapter.

[Placeables](https://projectfluent.org/fluent/guide/placeables.html) and [Functions](https://projectfluent.org/fluent/guide/functions.html) are two core features of the Fluent localization system.
This plugin injects some placeables and functions into your translation context and reduces your work of managing the translation context.

### Placeables

Placeables are used to inject data into a translation string.
For example, in a welcome message you may use the name of the user to greet them.
But you can't have messages for each user with their name in your translations.
Instead, you can pass their name in the translation context and the message will change according to the receiver. Here is how you would normally do it:

`en.ftl`

```fluent:no-line-numbers
welcome = Hi there, { $name }!
```

We can pass a value for the placeable `name`, in the translation context like this:

```ts:no-line-numbers
await ctx.reply(ctx.t("welcome", { name: ctx.from.first_name }))
```

Then the message will be different for each user, with their own first names in it.

#### `first_name`

It is a replacement for `ctx.from.first_name`.
So, you don't need to pass it in the context when you need it. You can just use it directly like this

```fluent:no-line-numbers
greeting = Hi { $first_name }
```

### Functions

Functions are like placeables. But unlike placables, functions get executed and replaced by the value it returns in the final output.

#### `CTX`

This function can help you to access any properties of the bot context directly from your translations.

```fluent:no-line-numbers
id = Your user ID: { CTX("from.id") }
```

The `CTX("from.id")` will get replaced by `ctx.from.id`.

Optionally, you can pass in a default value as the second argument.
If the value is undefined, the default value is used instead.

```fluent:no-line-numbers
id = Last name: { CTX("from.last_name", "You don't have a last name.") }
```

## Listening for Translated Text

We managed to send translated texts to the user.
Now imagine, what if the user sends the bot a text?
Yes, we use the `bot.hears` to handle them.
But, what if the user sends a translated version of the text we're trying to listen to?
This plugin also makes this part easy for you.

```ts
bot.hears("Hello", async (ctx) => {
  // handle update
});
bot.hears("Hallo", async (ctx) => {
  // handle update
});
```

If those handlers are the same, we could do this:

```ts
bot.hears(["Hello", "Hallo"], async (ctx) => {
  // handle update
});
```

But, it is kind of hard to list out all the translations to listen for.
With the `t` method from the i18n instance, you can do this:

```ts
bot.hears(i18n.t("welcome-text"), async (ctx) => {
  // handle update
});
```

::: warning

Make sure to load all of the translations before using this method.
Otherwise, you cannot listen to all of the translations.

:::

## Further Steps

- Complete reading the [Fluent documentation](https://projectfluent.org/), especially the [syntax guide](https://projectfluent.org/fluent/guide/).
- Check out proper [examples](https://github.com/grammyjs/i18n/tree/main/examples) of this plugin for Deno and Node.

## Plugin Summary

- Name: `i18n`
- Source: <https://github.com/grammyjs/i18n>
- API Reference: <https://doc.deno.land/https://deno.land/x/grammy_i18n/mod.ts>
